<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marble Roulette</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }
        #input-area {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            z-index: 100;
            width: 90%;
            max-width: 450px;
            backdrop-filter: blur(10px);
        }
        #input-area h2 {
            margin-bottom: 20px;
            font-size: 28px;
            color: #667eea;
            text-align: center;
            font-weight: 700;
        }
        #choices-input {
            width: 100%;
            height: 120px;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            font-size: 16px;
            resize: none;
            transition: border-color 0.3s;
            font-family: inherit;
        }
        #choices-input:focus {
            outline: none;
            border-color: #667eea;
        }
        #start-btn {
            width: 100%;
            padding: 16px;
            margin-top: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        #start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        #start-btn:active {
            transform: translateY(0);
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #canvas-container canvas {
            display: block;
        }
        #result-display {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            border-radius: 25px;
            padding: 50px 60px;
            text-align: center;
            z-index: 200;
            max-width: 80%;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.4);
            animation: resultPopup 0.4s ease-out;
        }
        @keyframes resultPopup {
            0% {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }
        #result-display h1 {
            font-size: 32px;
            margin-bottom: 15px;
            color: #667eea;
            font-weight: 700;
        }
        #result-display p {
            font-size: 36px;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 20px 0;
        }
        #reset-btn {
            margin-top: 25px;
            padding: 14px 40px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        #reset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        #reset-btn:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div id="input-area">
        <h2>선택지를 입력하세요</h2>
        <textarea id="choices-input" placeholder="선택지1&#10;선택지2&#10;선택지3&#10;(또는 쉼표로 구분)"></textarea>
        <button id="start-btn">START</button>
    </div>

    <div id="canvas-container"></div>

    <div id="result-display">
        <h1>결과</h1>
        <p id="result-text"></p>
        <button id="reset-btn">다시 하기</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    
    <script>
        const { Engine, Render, Runner, Bodies, Composite, Events } = Matter;

        let engine, render, runner;
        let marbles = [];
        let obstacles = [];
        let blackholeActive = false;
        let gameEnded = false;
        let centerX, centerY;
        let resistanceTimers = {};
        let blackholePower = 0;

        const inputArea = document.getElementById('input-area');
        const choicesInput = document.getElementById('choices-input');
        const startBtn = document.getElementById('start-btn');
        const resultDisplay = document.getElementById('result-display');
        const resultText = document.getElementById('result-text');
        const resetBtn = document.getElementById('reset-btn');

        startBtn.addEventListener('click', startGame);
        resetBtn.addEventListener('click', resetGame);

        function startGame() {
            const inputText = choicesInput.value.trim();
            if (!inputText) {
                alert('선택지를 입력해주세요!');
                return;
            }

            let choices = inputText.split(/[\n,]/).map(c => c.trim()).filter(c => c);
            
            if (choices.length < 2) {
                alert('최소 2개 이상의 선택지를 입력해주세요!');
                return;
            }

            inputArea.style.display = 'none';
            initPhysics(choices);
        }

        function initPhysics(choices) {
            const width = window.innerWidth;
            const height = window.innerHeight;
            centerX = width / 2;
            centerY = height / 2;

            engine = Engine.create();
            engine.gravity.y = 0;

            render = Render.create({
                element: document.getElementById('canvas-container'),
                engine: engine,
                options: {
                    width: width,
                    height: height,
                    wireframes: false,
                    background: 'transparent',
                    showAngleIndicator: false,
                    showVelocity: false
                }
            });

            console.log('렌더러 생성 완료');

            const wallThickness = 50;
            const walls = [
                Bodies.rectangle(width / 2, -wallThickness / 2, width, wallThickness, { 
                    isStatic: true,
                    render: { fillStyle: 'rgba(255, 255, 255, 0.1)' }
                }),
                Bodies.rectangle(width / 2, height + wallThickness / 2, width, wallThickness, { 
                    isStatic: true,
                    render: { fillStyle: 'rgba(255, 255, 255, 0.1)' }
                }),
                Bodies.rectangle(-wallThickness / 2, height / 2, wallThickness, height, { 
                    isStatic: true,
                    render: { fillStyle: 'rgba(255, 255, 255, 0.1)' }
                }),
                Bodies.rectangle(width + wallThickness / 2, height / 2, wallThickness, height, { 
                    isStatic: true,
                    render: { fillStyle: 'rgba(255, 255, 255, 0.1)' }
                })
            ];

            // 블랙홀 - 더 멋진 디자인
            const blackhole = Bodies.circle(centerX, centerY, 50, {
                isStatic: true,
                isSensor: true,
                render: { 
                    fillStyle: '#1a1a2e',
                    strokeStyle: '#667eea',
                    lineWidth: 5
                }
            });

            // 장애물 생성 - 랜덤 배치 (원형, 사각형, 삼각형)
            obstacles = [];
            console.log('=== 장애물 생성 시작 ===');
            console.log('화면 크기:', width, 'x', height);
            console.log('중심:', centerX, centerY);
            
            const obstacleCount = 8; // 장애물 개수
            
            for (let i = 0; i < obstacleCount; i++) {
                let obsX, obsY, distFromCenter;
                let attempts = 0;
                
                // 완전 랜덤 위치 생성
                do {
                    // 화면 전체에서 랜덤 선택 (마진 100)
                    obsX = 100 + Math.random() * (width - 200);
                    obsY = 100 + Math.random() * (height - 200);
                    
                    const dx = obsX - centerX;
                    const dy = obsY - centerY;
                    distFromCenter = Math.sqrt(dx * dx + dy * dy);
                    attempts++;
                    
                    if (attempts > 50) {
                        console.log(`장애물 ${i + 1}: 50번 시도 후 강제 배치`);
                        break;
                    }
                } while (distFromCenter < 100); // 블랙홀에서 최소 100 거리
                
                // 랜덤하게 모양 선택 (0: 원, 1: 사각형, 2: 삼각형)
                const shapeType = Math.floor(Math.random() * 3);
                let obstacle;
                
                // 랜덤 색상
                const colors = ['#FF6B9D', '#FFA726', '#66BB6A', '#42A5F5', '#AB47BC', '#26C6DA'];
                const randomColor = colors[Math.floor(Math.random() * colors.length)];
                
                if (shapeType === 0) {
                    // 원형
                    const radius = 40 + Math.random() * 30;
                    obstacle = Bodies.circle(obsX, obsY, radius, {
                        isStatic: true,
                        restitution: 1.8,
                        friction: 0,
                        render: {
                            fillStyle: randomColor,
                            strokeStyle: 'rgba(255, 255, 255, 0.8)',
                            lineWidth: 4
                        }
                    });
                    console.log(`장애물 ${i + 1}: 원형, 위치(${Math.round(obsX)}, ${Math.round(obsY)}), 반지름 ${Math.round(radius)}`);
                } else if (shapeType === 1) {
                    // 사각형
                    const size = 60 + Math.random() * 40;
                    const angle = Math.random() * Math.PI;
                    obstacle = Bodies.rectangle(obsX, obsY, size, size, {
                        isStatic: true,
                        angle: angle,
                        restitution: 1.8,
                        friction: 0,
                        render: {
                            fillStyle: randomColor,
                            strokeStyle: 'rgba(255, 255, 255, 0.8)',
                            lineWidth: 4
                        }
                    });
                    console.log(`장애물 ${i + 1}: 사각형, 위치(${Math.round(obsX)}, ${Math.round(obsY)}), 크기 ${Math.round(size)}, 각도 ${Math.round(angle * 180 / Math.PI)}°`);
                } else {
                    // 삼각형
                    const size = 70 + Math.random() * 40;
                    const angle = Math.random() * Math.PI * 2;
                    
                    obstacle = Bodies.polygon(obsX, obsY, 3, size * 0.6, {
                        isStatic: true,
                        angle: angle,
                        restitution: 1.8,
                        friction: 0,
                        render: {
                            fillStyle: randomColor,
                            strokeStyle: 'rgba(255, 255, 255, 0.8)',
                            lineWidth: 4
                        }
                    });
                    console.log(`장애물 ${i + 1}: 삼각형, 위치(${Math.round(obsX)}, ${Math.round(obsY)}), 크기 ${Math.round(size)}, 각도 ${Math.round(angle * 180 / Math.PI)}°`);
                }
                
                obstacles.push(obstacle);
            }

            console.log(`총 ${obstacles.length}개 장애물 생성 완료 (랜덤 배치)`);

            // 구슬 생성
            marbles = [];
            const marbleRadius = 35;
            const colors = [
                '#FF6B9D', '#C44569', '#FFA726', '#FFC947', 
                '#66BB6A', '#26C6DA', '#42A5F5', '#AB47BC'
            ];

            choices.forEach((choice, index) => {
                let x, y, distanceFromCenter;
                let attempts = 0;
                do {
                    const corner = Math.floor(Math.random() * 4);
                    const margin = 100;
                    
                    if (corner === 0) {
                        x = Math.random() * (width * 0.3) + margin;
                        y = Math.random() * (height * 0.3) + margin;
                    } else if (corner === 1) {
                        x = Math.random() * (width * 0.3) + width * 0.7 - margin;
                        y = Math.random() * (height * 0.3) + margin;
                    } else if (corner === 2) {
                        x = Math.random() * (width * 0.3) + margin;
                        y = Math.random() * (height * 0.3) + height * 0.7 - margin;
                    } else {
                        x = Math.random() * (width * 0.3) + width * 0.7 - margin;
                        y = Math.random() * (height * 0.3) + height * 0.7 - margin;
                    }
                    
                    const dx = x - centerX;
                    const dy = y - centerY;
                    distanceFromCenter = Math.sqrt(dx * dx + dy * dy);
                    attempts++;
                    
                    if (attempts > 50) break;
                } while (distanceFromCenter < 400);

                const marble = Bodies.circle(x, y, marbleRadius, {
                    restitution: 0.8,
                    friction: 0.01,
                    frictionAir: 0.001,
                    density: 0.002,
                    render: {
                        fillStyle: colors[index % colors.length],
                        strokeStyle: 'rgba(255, 255, 255, 0.5)',
                        lineWidth: 3
                    }
                });

                const velocityX = (Math.random() - 0.5) * 15;
                const velocityY = (Math.random() - 0.5) * 15;
                Matter.Body.setVelocity(marble, { x: velocityX, y: velocityY });
                Matter.Body.setAngularVelocity(marble, (Math.random() - 0.5) * 0.2);

                marble.label = choice;
                marble.customId = 'marble_' + index;
                resistanceTimers[marble.customId] = 0;

                marbles.push(marble);
            });

            // 모든 객체를 world에 추가
            console.log('=== World에 객체 추가 중 ===');
            console.log('벽:', walls.length);
            console.log('블랙홀: 1');
            console.log('장애물:', obstacles.length);
            console.log('구슬:', marbles.length);
            
            Composite.add(engine.world, walls);
            Composite.add(engine.world, blackhole);
            Composite.add(engine.world, obstacles);
            Composite.add(engine.world, marbles);
            
            console.log('World 총 객체 수:', engine.world.bodies.length);
            console.log('장애물들:', obstacles.map(o => ({ x: o.position.x, y: o.position.y, radius: o.circleRadius })));

            Render.run(render);
            console.log('렌더링 시작');
            
            runner = Runner.create();
            Runner.run(runner, engine);

            Events.on(engine, 'beforeUpdate', updateGame);
            Events.on(render, 'afterRender', drawMarbleLabels);

            setTimeout(() => {
                blackholeActive = true;
                const powerInterval = setInterval(() => {
                    if (gameEnded) {
                        clearInterval(powerInterval);
                        return;
                    }
                    blackholePower = Math.min(blackholePower + 0.1, 3);
                }, 500);
            }, 3000);
        }

        function updateGame() {
            if (gameEnded) return;

            if (blackholeActive) {
                marbles.forEach(marble => {
                    const dx = centerX - marble.position.x;
                    const dy = centerY - marble.position.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    let baseForceMagnitude;
                    if (distance > 300) {
                        baseForceMagnitude = 0.00008;
                    } else if (distance > 150) {
                        baseForceMagnitude = 0.0003;
                    } else if (distance > 80) {
                        baseForceMagnitude = 0.001;
                    } else {
                        baseForceMagnitude = 0.003;
                    }
                    
                    const forceMagnitude = baseForceMagnitude * (1 + blackholePower);
                    const forceX = (dx / distance) * forceMagnitude;
                    const forceY = (dy / distance) * forceMagnitude;

                    Matter.Body.applyForce(marble, marble.position, { x: forceX, y: forceY });

                    resistanceTimers[marble.customId] = (resistanceTimers[marble.customId] || 0) + 1;
                    const resistInterval = 20 + Math.floor(Math.random() * 20);
                    if (resistanceTimers[marble.customId] % resistInterval === 0) {
                        const resistanceStrength = Math.min(distance / 150, 1) * 0.0005;
                        const randomAngle = (Math.random() - 0.5) * Math.PI / 1.5;
                        const resistX = -dx / distance;
                        const resistY = -dy / distance;
                        const finalResistX = (resistX * Math.cos(randomAngle) - resistY * Math.sin(randomAngle)) * resistanceStrength;
                        const finalResistY = (resistX * Math.sin(randomAngle) + resistY * Math.cos(randomAngle)) * resistanceStrength;
                        Matter.Body.applyForce(marble, marble.position, { x: finalResistX, y: finalResistY });
                        Matter.Body.setAngularVelocity(marble, marble.angularVelocity + (Math.random() - 0.5) * 0.3);
                    }
                    
                    if (distance < 200) {
                        const spinIncrease = (200 - distance) / 20000;
                        Matter.Body.setAngularVelocity(marble, marble.angularVelocity + spinIncrease);
                    }

                    if (distance < 45 && !gameEnded) {
                        endGame(marble.label);
                    }
                });
                
                for (let i = 0; i < marbles.length; i++) {
                    for (let j = i + 1; j < marbles.length; j++) {
                        const marble1 = marbles[i];
                        const marble2 = marbles[j];
                        const dx = marble2.position.x - marble1.position.x;
                        const dy = marble2.position.y - marble1.position.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 100 && distance > 0) {
                            const repelForce = 0.00002 / (distance * distance);
                            const repelX = (dx / distance) * repelForce;
                            const repelY = (dy / distance) * repelForce;
                            Matter.Body.applyForce(marble1, marble1.position, { x: -repelX, y: -repelY });
                            Matter.Body.applyForce(marble2, marble2.position, { x: repelX, y: repelY });
                        }
                    }
                }
            }
        }

        function drawMarbleLabels() {
            const context = render.context;
            context.font = 'bold 15px Segoe UI';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillStyle = 'white';
            context.shadowColor = 'rgba(0, 0, 0, 0.5)';
            context.shadowBlur = 4;

            marbles.forEach(marble => {
                const pos = marble.position;
                context.save();
                context.translate(pos.x, pos.y);
                context.rotate(marble.angle);
                let label = marble.label;
                if (label.length > 8) {
                    label = label.substring(0, 7) + '...';
                }
                context.fillText(label, 0, 0);
                context.restore();
            });
            
            context.shadowBlur = 0;
        }

        function endGame(winnerLabel) {
            gameEnded = true;
            blackholeActive = false;
            Runner.stop(runner);
            resultText.textContent = winnerLabel;
            resultDisplay.style.display = 'block';
        }

        function resetGame() {
            if (render) {
                Render.stop(render);
                render.canvas.remove();
                render.textures = {};
            }
            if (engine) {
                Engine.clear(engine);
            }

            marbles = [];
            obstacles = [];
            blackholeActive = false;
            gameEnded = false;
            resistanceTimers = {};
            blackholePower = 0;

            resultDisplay.style.display = 'none';
            inputArea.style.display = 'block';
            choicesInput.value = '';
        }

        window.addEventListener('resize', () => {
            if (render) {
                render.canvas.width = window.innerWidth;
                render.canvas.height = window.innerHeight;
                centerX = window.innerWidth / 2;
                centerY = window.innerHeight / 2;
            }
        });
    </script>
</body>
</html>